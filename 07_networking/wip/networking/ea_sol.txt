
------------------

- Model View Matrix

Objektumot a világba

- Projection Matrix:

A cam mátrix identitás: 
ebből következik:

x: -1, 1
y: -1, 1
z: -1, 1 

kockába ami van azt rajzolja ki az opengl

azaz mninden vertexet úgy mozgat a camera world mátrix, hogy ebbe legyen bent (amikor látszik)

- Egér koordináták 3d világba átszámolása

Azaz a 3d világ koordinátát akarjuk megkapni képernyő koordinátákból.

Először a képernyő koordinátákat át kell számolni -1,1   -1,1  közé
Majd a camera mátrix műveletének az ellentettjét kell elvégezni -> inverz mátrix

És ha egyenest akarunk: Ugyanez még egyszer, csak a z-n elmozgatva valamennyivel -> két pont

- Egér koordináta 2d-ben / Orthografikus kamerával:

Az előző módszer ugyanúgy működik 2dben

De sokszor egyszerűbben is kel lehet számolni kézzel, pl ui nál, ha tudjuk a koordináta renszert 
ált direktbe át lehet számolni a képernyő koordinátákat

-------------------

Pixel Perfect rendering:

(tilemap vis glitch show)

Ezt meg lehet javítani:
Vagy kis ráhagyásokkal a meshekbe
Vagy azzal, hogy a koordináta rendszerünket pixelméretben adjuk meg, és mindent intekké kerekítünk, amikor csak lehet.

----------------------

UI

Fő kamerával rajzolva:

Mindíg oda van rakva a kamera elé rajzolás előtt.

Saját kamerával rajzolva:

Valamelyik sarok ki van kiáltva 0, 0 nak -> bal felső vagy alső ált.

Kamera rá van állítva, és a fő kamera rajzolása után ez a képre rá van renderelve.

----------------------

UI Koordináta rendszer

Low res uinál lehet pixel perfekten

De például lehet azt is mondani, hogy a magasság mindíg 100 egység legyen, és a szélességet változtatjuk a képarány szerint,
így gyakorlatilag képmagasság százalékban tudjuk elhelyezni az elemeket.

-------------------

3d/fps camera strafe

cross produkt -> vektoriális szorzat

up vektor + forward vektor
forward vektor -> ha azt mondjuk, hogy x+ flee néz a karakter/kamera, akkor a (1, 0, 0) vektort elforgatjuk a karakter/kamera 
rotation vektorában tárolt fokokkal.

--------------------

Ütközés viszgálat

Sok módszer van.

pl:

Tilemapnál lehet viszgálni direkte a tile-kat, pl amikor a karaktert mozgatni akarjuk, és olyan tilére lépne, amire nem lehet akkor nem engedjük mozogni.

Itt az a gond, hogy változó fps-nél néha tavolabb áll meg a karaketer egy faltól. -> Csinálhatjuk több lépésben.

Mindkét módszernél másik probléma, hogy egy lépés ha túl nagy át lehet menni falakon. Pl Super Mario 64 speedrunok is használnak ilyeneket.

Elég nagy sebességnél, lehet több részre bontani etc.

--------------------

Fizikai motorok

Box2D
BulletPhysics

NVidia PhysX, Havoc etc

Ált külön fix frekvenciával működnek -> sokszor külön szálon.
Ált 60 hz per sec.

Elvileg stabilabbak az aloritmusok így + valószínűleg optimalizációt is jelent.

Nagy timestep -> többször le kell futtatni.

Ált játékmotorokban külön van physics update ezért.

Használhatóak ütközlsvizsgálatra is.

-------------------

Framerate + munka + UI

Játékokba (néha normál appokba is) ha sok munkát végzünk a fő szálon, a program láthatóan megakadhat.

Pl 4-5 másodpercig ha számolunk a fő szálon -> addíg nem használható az app guija se!

Játékok erre jóval érzékenyebbek -> framerate ha leesik 60 ról 30 ra pár pillanatra, már az is észrevehető.

Szóval ilyen munkákat vagy megszakíthatóra kell tenni, és folytatni mindíg (Pl yield néháyn programnyelvbe, vagy
csak el kell tárolni, hogy hol tart.), vagy másik szálon futtatni.

-------------------

Nwtworking

Bármikor küldhetünk üzenetet bármilyen gépnek, ha van címünk -> hogy fogadja e a gép, az más kérdés.

DOS, DDOS
Aplification -> open dns servers

https://www.cloudflare.com/learning/ddos/glossary/user-datagram-protocol-udp/
https://www.guru99.com/tcp-3-way-handshake.html

Minden adat csomagokban megy el a küldőtől a címzettig, ezeknek van méret limitje.
Csomag -> mint egy levél, címzettel plussz adat
Cím -> mac address + ip cím -> lehet, hogy átíródik -> NAT pl
Mac address -> egyedinek kell lennie minden eszköznek! 
Néha átírható ideiglenesen -> mac spoofing. Van, hogy támadás, de pl van, hogy routereknél kell, hogy működjön.

-------------------

Transport Layer Protocols

https://en.wikipedia.org/wiki/User_Datagram_Protocol 
bal oldal

TCP

-Minden csomagra figyel, hogy megérkezzen.
-Minden csomagra figyel, hogy a megfelelő sorrendben érkezzen meg. (Az app szemszögéből)
-Ha egy csomag kimarad / elveszik újra lekéri a szervertől.
-TCP Three-way handshake -> SYN, SYN/ACK, ACK

-Néhány TCP specifikus támadás -> SYN flood, ACK flood, TCP Reset -> más nevében küldenek TCP reset csomagot

UDP

-Gyors
-Csomag elveszhet -> QoS, hibák etc
-Csomagok más sorrendben érkezhetnek meg -> routing változás pl
-Egy gép csak megnyithat UDP csatornát, és küldhet adatot

...

-------------------

Application Layer Protocols

HTTP - Hypertext Transfer Protocol

https://code.tutsplus.com/tutorials/http-headers-for-dummies--net-8039

browser:

GET /tutorials/other/top-20-mysql-best-practices/ HTTP/1.1
Host: net.tutsplus.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Cookie: PHPSESSID=r2t5uvjq435r4q7ib3vtdjq120
Pragma: no-cache
Cache-Control: no-cache

Response:

HTTP/1.x 200 OK
Transfer-Encoding: chunked
Date: Sat, 28 Nov 2009 04:36:25 GMT
Server: LiteSpeed
Connection: close
X-Powered-By: W3 Total Cache/0.8
Pragma: public
Expires: Sat, 28 Nov 2009 05:36:25 GMT
Etag: "pub1259380237;gz"
Cache-Control: max-age=3600, public
Content-Type: text/html; charset=UTF-8
Last-Modified: Sat, 28 Nov 2009 03:50:37 GMT
X-Pingback: https://net.tutsplus.com/xmlrpc.php
Content-Encoding: gzip
Vary: Accept-Encoding, Cookie, User-Agent
 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Top 20+ MySQL Best Practices - Nettuts+</title>
<!-- ... rest of the html ... -->

Azaz triviális bármilyen nyelven webszervert/weblapot írni!

https://en.wikipedia.org/wiki/List_of_HTTP_header_fields


Van sok egyéb, mi is ilyet írunk, ha saját csomagokat használunk.

Pl:

Csatolakozunk egy játékszerverhez, és küldünk egy ilyet:

01|username|password_hash

01 -> CLIENT_PACKET_LOGIN enum érték

Válasz:

01|1

01 -> SERVER_PACKET_LOGIN_RESULT enum érték
1 ->  OK

Vagy:

Kliens->szerver:

14|134.123|112.23|15.3

14 -> SERVER_PACKET_NEW_PLAYER_POSITION enum érték
utána x, y, z koordináták ->  szerver frissíti a kliens karakteréne a helyzetét, és elküldi minden más kliensnek:

17|3|134.123|112.23|15.3

17 -> CLIENT_PACKET_NEW_PLAYER_POSITION enum érték
utána player id, x, y, z koordináták

stb 

Ha ez UDPn megy (Tipikusan ez amit UDP vel szoktak küldeni) -> kell timestamp, hogy el lehessen dobni, ha régebbi később ér oda

--------------------

Csalás megakadályozása:

Ha ilyenre kell figyelni (CS pl)

Nem koordinátákat küldenek, hanem gombokat -> szerver szimulálja, hogy hol  a karakter-> visszaküldi kliensnek

CS be nem várhatunk 1 mp-et, hogy egy gombnyomást érzékeljen

client side prediction -> azaz úgy teszünk kliens oldalon, hogy a szerver elfogadta a bemenetet, és ha esetleg nem, akkor kijavítjuk arra, amit a szerver mond.

Egyéb:
Van, hogy DLL inkjction-okat detektálnak, stb 


