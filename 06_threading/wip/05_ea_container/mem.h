
hex 

0xF -> 1111
0xFF -> 1111 1111 -> 1byte
0xFFFFFFFF -> max uint

bitmanipuláció

bitwise and -> & 
logical and -> &&

0x01 & 0x0F -> 0x01
0000 0001 & 0000 1111 -> 0000 0001

bitwise or -> | 
logical or -> ||

0x01 & 0x0F -> 0x01
0000 0001 & 0000 1111 -> 0000 1111

bit shift

left shift

0000 0001 << 1 -> 0000 0010 

right shift

0000 0010 >> 1 -> 0000 0001 

bit packing

void set_collision_mask(bool layer1, bool layer2, .....)
void set_collision_mask(uint layers)
void set_collision_layer(uint layers)

0010 0011 -> 

0010 0011 & 0x0F -> 0010 0011 & 0000 1111 -> 0000 0011
0010 0011 & 0xF0 -> 0010 0011 & 1111 0000 -> 0010 0000

0010 0011 >> 4 -> 0000 0010

bitflag

enum BuildFlags {
	BUILD_FLAG_USE_ISOLEVEL = 1 << 0,    0000 0001
	BUILD_FLAG_USE_LIGHTING = 1 << 1,    0000 0010
	BUILD_FLAG_USE_AO = 1 << 2,          0000 0100
	BUILD_FLAG_USE_RAO = 1 << 3,
	BUILD_FLAG_GENERATE_AO = 1 << 4,
	BUILD_FLAG_AUTO_GENERATE_RAO = 1 << 5,
	BUILD_FLAG_BAKE_LIGHTS = 1 << 6,
	BUILD_FLAG_CREATE_COLLIDER = 1 << 7,
	BUILD_FLAG_CREATE_LODS = 1 << 8,     1000 0000
};

//static int BUILD_FLAG_USE_ISOLEVEL = 1 << 0;

int flags = BUILD_FLAG_USE_ISOLEVEL | BUILD_FLAG_USE_LIGHTING | BUILD_FLAG_CREATE_LODS -> 1000 0011

flags & BUILD_FLAG_USE_ISOLEVEL != 0 -> a flag jelen van (-> 0000 0001)

 
if (flags & BUILD_FLAG_USE_ISOLEVEL) -> c, c++

mamória

valójában 1ds tömb!

64 bites os -> 64 bites int nagyságó cím

0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x14 0xF1 0x61 0x12 0x12 0x11 0x33
0x11 0xF1 0x11 0x12 0x12 0x11 0x33
0x11 0xF1 0x11 0x12 0x12 0x11 0x33
0x11 0xA1 0x11 0x12 0x12 0x11 0x33
0x11 0xE1 0x11 0x12 0x12 0x11 0x33
0x11 0xA1 0x11 0x12 0x12 0x11 0x33
0x11 0xF1 0x11 0x12 0x12 0x11 0x33
0x11 0xF1 0x11 0x12 0x12 0x11 0x33
0x11 0xF1 0x11 0x12 0x12 0x11 0x33
0x11 0xF1 0x11 0x12 0x12 0x11 0x33
0x00 0x00 0x00 0x00 0x00 0x00 0x00
0x00 0x00 0x00 0x00 0x00 0x00 0x00
...

A0, A1, A2
ADD A0, A1

square(int): -> (label) memóriacím lessz
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
.L3:  
        cmp     DWORD PTR [rbp-4], 999
        jg      .L2
        add     DWORD PTR [rbp-4], 1
        jmp     .L3
.L2: 
        mov     eax, DWORD PTR [rbp-4]
        pop     rbp
        ret

0x14 -> push
0x11 -> jg
0xF1 -> mov

//eredeti kód
int square(int num) {

    while (num < 1000) {
        num += 1;
    }

    return num;
}